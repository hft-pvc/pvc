   1               		.file	"slam.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	acsStateChanged
  12               	acsStateChanged:
  13               	.LFB5:
  14               		.file 1 "src/slam.c"
   1:src/slam.c    **** /* 
   2:src/slam.c    ****  * ****************************************************************************
   3:src/slam.c    ****  * RP6 ROBOT SYSTEM - ROBOT BASE EXAMPLES
   4:src/slam.c    ****  * ****************************************************************************
   5:src/slam.c    ****  * Example: Movement 5
   6:src/slam.c    ****  * Author(s): Dominik S. Herwald
   7:src/slam.c    ****  * ****************************************************************************
   8:src/slam.c    ****  * Description:
   9:src/slam.c    ****  *
  10:src/slam.c    ****  * In this example we add a new behaviour to our subsumption architechture. 
  11:src/slam.c    ****  * We call it "avoid". This behaviour tries to avoid collisions with 
  12:src/slam.c    ****  * obstacles by using the two ACS channels. 
  13:src/slam.c    ****  *
  14:src/slam.c    ****  * The escape behaviour from the previous example is NOT changed at all! 
  15:src/slam.c    ****  * Also the other routines stay like they are, except that we add the new
  16:src/slam.c    ****  * Behaviour to the behaviourController function.
  17:src/slam.c    ****  *
  18:src/slam.c    ****  * ############################################################################
  19:src/slam.c    ****  * #+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+
  20:src/slam.c    ****  * 
  21:src/slam.c    ****  * ATTENTION: THE ROBOT MOVES AROUND IN THIS EXAMPLE! PLEASE PROVIDE ABOUT
  22:src/slam.c    ****  * 2m x 2m OR MORE FREE SPACE FOR THE ROBOT! 
  23:src/slam.c    ****  *
  24:src/slam.c    ****  * >>> DO NOT FORGET TO REMOVE THE FLAT CABLE CONNECTION TO THE USB INTERFACE
  25:src/slam.c    ****  * BEFORE YOU START THIS PROGRAM BY PRESSING THE START BUTTON ON THE ROBOT!
  26:src/slam.c    ****  *
  27:src/slam.c    ****  * #+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+
  28:src/slam.c    ****  * ############################################################################
  29:src/slam.c    ****  * ****************************************************************************
  30:src/slam.c    ****  */
  31:src/slam.c    **** 
  32:src/slam.c    **** /*****************************************************************************/
  33:src/slam.c    **** // Includes:
  34:src/slam.c    **** 
  35:src/slam.c    **** #include "RP6RobotBaseLib.h" 	
  36:src/slam.c    **** 
  37:src/slam.c    **** /*****************************************************************************/
  38:src/slam.c    **** // Behaviour command type:
  39:src/slam.c    **** 
  40:src/slam.c    **** #define IDLE  0
  41:src/slam.c    **** 
  42:src/slam.c    **** // The behaviour command data type:
  43:src/slam.c    **** typedef struct {
  44:src/slam.c    **** 	uint8_t  speed_left;  // left speed (is used for rotation and 
  45:src/slam.c    **** 						  // move distance commands - if these commands are 
  46:src/slam.c    **** 						  // active, speed_right is ignored!)
  47:src/slam.c    **** 	uint8_t  speed_right; // right speed
  48:src/slam.c    **** 	unsigned dir:2;       // direction (FWD, BWD, LEFT, RIGHT)
  49:src/slam.c    **** 	unsigned move:1;      // move flag
  50:src/slam.c    **** 	unsigned rotate:1;    // rotate flag
  51:src/slam.c    **** 	uint16_t move_value;  // move value is used for distance and angle values
  52:src/slam.c    **** 	uint8_t  state;       // state of the behaviour
  53:src/slam.c    **** } behaviour_command_t;
  54:src/slam.c    **** 
  55:src/slam.c    **** behaviour_command_t STOP = {0, 0, FWD, false, false, 0, IDLE};
  56:src/slam.c    **** 
  57:src/slam.c    **** /*****************************************************************************/
  58:src/slam.c    **** // Cruise Behaviour:
  59:src/slam.c    **** 
  60:src/slam.c    **** #define CRUISE_SPEED_FWD    100 //40 // 100 Default speed when no obstacles are detected!
  61:src/slam.c    **** 
  62:src/slam.c    **** #define MOVE_FORWARDS 1
  63:src/slam.c    **** behaviour_command_t cruise = {CRUISE_SPEED_FWD, CRUISE_SPEED_FWD, FWD, 
  64:src/slam.c    **** 								false, false, 0, MOVE_FORWARDS};
  65:src/slam.c    **** 
  66:src/slam.c    **** /**
  67:src/slam.c    ****  * We don't have anything to do here - this behaviour has only
  68:src/slam.c    ****  * a constant value for moving forwards - s. above!
  69:src/slam.c    ****  * Of course you can change this and add some random or timed movements 
  70:src/slam.c    ****  * in here...
  71:src/slam.c    ****  */
  72:src/slam.c    **** void behaviour_cruise(void)
  73:src/slam.c    **** {
  74:src/slam.c    **** }
  75:src/slam.c    **** 
  76:src/slam.c    **** /*****************************************************************************/
  77:src/slam.c    **** // Escape Behaviour:
  78:src/slam.c    **** 
  79:src/slam.c    **** #define ESCAPE_SPEED_BWD    100 //40 // 100
  80:src/slam.c    **** #define ESCAPE_SPEED_ROTATE 60 //30  // 60
  81:src/slam.c    **** 
  82:src/slam.c    **** #define ESCAPE_FRONT		1
  83:src/slam.c    **** #define ESCAPE_FRONT_WAIT 	2
  84:src/slam.c    **** #define ESCAPE_LEFT  		3
  85:src/slam.c    **** #define ESCAPE_LEFT_WAIT	4
  86:src/slam.c    **** #define ESCAPE_RIGHT	    5
  87:src/slam.c    **** #define ESCAPE_RIGHT_WAIT 	6
  88:src/slam.c    **** #define ESCAPE_WAIT_END		7
  89:src/slam.c    **** behaviour_command_t escape = {0, 0, FWD, false, false, 0, IDLE}; 
  90:src/slam.c    **** 
  91:src/slam.c    **** /**
  92:src/slam.c    ****  * This is the Escape behaviour for the Bumpers.
  93:src/slam.c    ****  */
  94:src/slam.c    **** void behaviour_escape(void)
  95:src/slam.c    **** {
  96:src/slam.c    **** 	static uint8_t bump_count = 0;
  97:src/slam.c    **** 	
  98:src/slam.c    **** 	switch(escape.state)
  99:src/slam.c    **** 	{
 100:src/slam.c    **** 		case IDLE: 
 101:src/slam.c    **** 		break;
 102:src/slam.c    **** 		case ESCAPE_FRONT:
 103:src/slam.c    **** 			escape.speed_left = ESCAPE_SPEED_BWD;
 104:src/slam.c    **** 			escape.dir = BWD;
 105:src/slam.c    **** 			escape.move = true;
 106:src/slam.c    **** 			if(bump_count > 3)
 107:src/slam.c    **** 				escape.move_value = 220;
 108:src/slam.c    **** 			else
 109:src/slam.c    **** 				escape.move_value = 160;
 110:src/slam.c    **** 			escape.state = ESCAPE_FRONT_WAIT;
 111:src/slam.c    **** 			bump_count+=2;
 112:src/slam.c    **** 		break;
 113:src/slam.c    **** 		case ESCAPE_FRONT_WAIT:			
 114:src/slam.c    **** 			if(!escape.move) // Wait for movement to be completed
 115:src/slam.c    **** 			{	
 116:src/slam.c    **** 				escape.speed_left = ESCAPE_SPEED_ROTATE;
 117:src/slam.c    **** 				if(bump_count > 3)
 118:src/slam.c    **** 				{
 119:src/slam.c    **** 					escape.move_value = 100;
 120:src/slam.c    **** 					escape.dir = RIGHT;
 121:src/slam.c    **** 					bump_count = 0;
 122:src/slam.c    **** 				}
 123:src/slam.c    **** 				else 
 124:src/slam.c    **** 				{
 125:src/slam.c    **** 					escape.dir = LEFT;
 126:src/slam.c    **** 					escape.move_value = 70;
 127:src/slam.c    **** 				}
 128:src/slam.c    **** 				escape.rotate = true;
 129:src/slam.c    **** 				escape.state = ESCAPE_WAIT_END;
 130:src/slam.c    **** 			}
 131:src/slam.c    **** 		break;
 132:src/slam.c    **** 		case ESCAPE_LEFT:
 133:src/slam.c    **** 			escape.speed_left = ESCAPE_SPEED_BWD;
 134:src/slam.c    **** 			escape.dir 	= BWD;
 135:src/slam.c    **** 			escape.move = true;
 136:src/slam.c    **** 			if(bump_count > 3)
 137:src/slam.c    **** 				escape.move_value = 190;
 138:src/slam.c    **** 			else
 139:src/slam.c    **** 				escape.move_value = 150;
 140:src/slam.c    **** 			escape.state = ESCAPE_LEFT_WAIT;
 141:src/slam.c    **** 			bump_count++;
 142:src/slam.c    **** 		break;
 143:src/slam.c    **** 		case ESCAPE_LEFT_WAIT:
 144:src/slam.c    **** 			if(!escape.move) // Wait for movement to be completed
 145:src/slam.c    **** 			{
 146:src/slam.c    **** 				escape.speed_left = ESCAPE_SPEED_ROTATE;
 147:src/slam.c    **** 				escape.dir = RIGHT;
 148:src/slam.c    **** 				escape.rotate = true;
 149:src/slam.c    **** 				if(bump_count > 3)
 150:src/slam.c    **** 				{
 151:src/slam.c    **** 					escape.move_value = 110;
 152:src/slam.c    **** 					bump_count = 0;
 153:src/slam.c    **** 				}
 154:src/slam.c    **** 				else
 155:src/slam.c    **** 					escape.move_value = 80;
 156:src/slam.c    **** 				escape.state = ESCAPE_WAIT_END;
 157:src/slam.c    **** 			}
 158:src/slam.c    **** 		break;
 159:src/slam.c    **** 		case ESCAPE_RIGHT:	
 160:src/slam.c    **** 			escape.speed_left = ESCAPE_SPEED_BWD;
 161:src/slam.c    **** 			escape.dir 	= BWD;
 162:src/slam.c    **** 			escape.move = true;
 163:src/slam.c    **** 			if(bump_count > 3)
 164:src/slam.c    **** 				escape.move_value = 190;
 165:src/slam.c    **** 			else
 166:src/slam.c    **** 				escape.move_value = 150;
 167:src/slam.c    **** 			escape.state = ESCAPE_RIGHT_WAIT;
 168:src/slam.c    **** 			bump_count++;
 169:src/slam.c    **** 		break;
 170:src/slam.c    **** 		case ESCAPE_RIGHT_WAIT:
 171:src/slam.c    **** 			if(!escape.move) // Wait for movement to be completed
 172:src/slam.c    **** 			{ 
 173:src/slam.c    **** 				escape.speed_left = ESCAPE_SPEED_ROTATE;		
 174:src/slam.c    **** 				escape.dir = LEFT;
 175:src/slam.c    **** 				escape.rotate = true;
 176:src/slam.c    **** 				if(bump_count > 3)
 177:src/slam.c    **** 				{
 178:src/slam.c    **** 					escape.move_value = 110;
 179:src/slam.c    **** 					bump_count = 0;
 180:src/slam.c    **** 				}
 181:src/slam.c    **** 				else
 182:src/slam.c    **** 					escape.move_value = 80;
 183:src/slam.c    **** 				escape.state = ESCAPE_WAIT_END;
 184:src/slam.c    **** 			}
 185:src/slam.c    **** 		break;
 186:src/slam.c    **** 		case ESCAPE_WAIT_END:
 187:src/slam.c    **** 			if(!(escape.move || escape.rotate)) // Wait for movement/rotation to be completed
 188:src/slam.c    **** 				escape.state = IDLE;
 189:src/slam.c    **** 		break;
 190:src/slam.c    **** 	}
 191:src/slam.c    **** }
 192:src/slam.c    **** 
 193:src/slam.c    **** /**
 194:src/slam.c    ****  * Bumpers Event handler
 195:src/slam.c    ****  */
 196:src/slam.c    **** void bumpersStateChanged(void)
 197:src/slam.c    **** {
 198:src/slam.c    **** 	if(bumper_left && bumper_right) // Both Bumpers were hit
 199:src/slam.c    **** 	{
 200:src/slam.c    **** 		escape.state = ESCAPE_FRONT;
 201:src/slam.c    **** 	}
 202:src/slam.c    **** 	else if(bumper_left)  			// Left Bumper was hit
 203:src/slam.c    **** 	{
 204:src/slam.c    **** 		if(escape.state != ESCAPE_FRONT_WAIT) 
 205:src/slam.c    **** 			escape.state = ESCAPE_LEFT;
 206:src/slam.c    **** 	}
 207:src/slam.c    **** 	else if(bumper_right) 			// Right Bumper was hit
 208:src/slam.c    **** 	{
 209:src/slam.c    **** 		if(escape.state != ESCAPE_FRONT_WAIT)
 210:src/slam.c    **** 			escape.state = ESCAPE_RIGHT;
 211:src/slam.c    **** 	}
 212:src/slam.c    **** }
 213:src/slam.c    **** 
 214:src/slam.c    **** /*****************************************************************************/
 215:src/slam.c    **** // The new Avoid Behaviour:
 216:src/slam.c    **** 
 217:src/slam.c    **** // Some speed values for different movements:
 218:src/slam.c    **** #define AVOID_SPEED_L_ARC_LEFT  30
 219:src/slam.c    **** #define AVOID_SPEED_L_ARC_RIGHT 100 //40 // 90
 220:src/slam.c    **** #define AVOID_SPEED_R_ARC_LEFT  100 //40 // 90
 221:src/slam.c    **** #define AVOID_SPEED_R_ARC_RIGHT 30
 222:src/slam.c    **** #define AVOID_SPEED_ROTATE 	60 //30     // 60
 223:src/slam.c    **** 
 224:src/slam.c    **** // States for the Avoid FSM:
 225:src/slam.c    **** #define AVOID_OBSTACLE_RIGHT 		1
 226:src/slam.c    **** #define AVOID_OBSTACLE_LEFT 		2
 227:src/slam.c    **** #define AVOID_OBSTACLE_MIDDLE	    3
 228:src/slam.c    **** #define AVOID_OBSTACLE_MIDDLE_WAIT 	4
 229:src/slam.c    **** #define AVOID_END 					5
 230:src/slam.c    **** behaviour_command_t avoid = {0, 0, FWD, false, false, 0, IDLE};
 231:src/slam.c    **** 
 232:src/slam.c    **** /**
 233:src/slam.c    ****  * The new avoid behaviour. It uses the two ACS channels to avoid
 234:src/slam.c    ****  * collisions with obstacles. It drives arcs or rotates depending
 235:src/slam.c    ****  * on the sensor states and also behaves different after some
 236:src/slam.c    ****  * detecting cycles to avoid lock up situations. 
 237:src/slam.c    ****  */
 238:src/slam.c    **** void behaviour_avoid(void)
 239:src/slam.c    **** {
 240:src/slam.c    **** 	static uint8_t last_obstacle = LEFT;
 241:src/slam.c    **** 	static uint8_t obstacle_counter = 0;
 242:src/slam.c    **** 	switch(avoid.state)
 243:src/slam.c    **** 	{
 244:src/slam.c    **** 		case IDLE: 
 245:src/slam.c    **** 		// This is different to the escape Behaviour where
 246:src/slam.c    **** 		// we used the Event Handler to detect sensor changes...
 247:src/slam.c    **** 		// Here we do this within the states!
 248:src/slam.c    **** 			if(obstacle_right && obstacle_left) // left AND right sensor have detected something...
 249:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 250:src/slam.c    **** 			else if(obstacle_left)  // Left "sensor" has detected something
 251:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_LEFT;
 252:src/slam.c    **** 			else if(obstacle_right) // Right "sensor" has detected something
 253:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_RIGHT;
 254:src/slam.c    **** 		break;
 255:src/slam.c    **** 		case AVOID_OBSTACLE_MIDDLE:
 256:src/slam.c    **** 			avoid.dir = last_obstacle;
 257:src/slam.c    **** 			avoid.speed_left = AVOID_SPEED_ROTATE;
 258:src/slam.c    **** 			avoid.speed_right = AVOID_SPEED_ROTATE;
 259:src/slam.c    **** 			if(!(obstacle_left || obstacle_right))
 260:src/slam.c    **** 			{
 261:src/slam.c    **** 				if(obstacle_counter > 3)
 262:src/slam.c    **** 				{
 263:src/slam.c    **** 					obstacle_counter = 0;
 264:src/slam.c    **** 					setStopwatch4(0);
 265:src/slam.c    **** 				}
 266:src/slam.c    **** 				else
 267:src/slam.c    **** 					setStopwatch4(400);
 268:src/slam.c    **** 				startStopwatch4();
 269:src/slam.c    **** 				avoid.state = AVOID_END;
 270:src/slam.c    **** 			}
 271:src/slam.c    **** 		break;
 272:src/slam.c    **** 		case AVOID_OBSTACLE_RIGHT:
 273:src/slam.c    **** 			avoid.dir = FWD;
 274:src/slam.c    **** 			avoid.speed_left = AVOID_SPEED_L_ARC_LEFT;
 275:src/slam.c    **** 			avoid.speed_right = AVOID_SPEED_L_ARC_RIGHT;
 276:src/slam.c    **** 			if(obstacle_right && obstacle_left)
 277:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 278:src/slam.c    **** 			if(!obstacle_right)
 279:src/slam.c    **** 			{
 280:src/slam.c    **** 				setStopwatch4(500);
 281:src/slam.c    **** 				startStopwatch4();
 282:src/slam.c    **** 				avoid.state = AVOID_END;
 283:src/slam.c    **** 			}
 284:src/slam.c    **** 			last_obstacle = RIGHT;
 285:src/slam.c    **** 			obstacle_counter++;
 286:src/slam.c    **** 		break;
 287:src/slam.c    **** 		case AVOID_OBSTACLE_LEFT:
 288:src/slam.c    **** 			avoid.dir = FWD;
 289:src/slam.c    **** 			avoid.speed_left = AVOID_SPEED_R_ARC_LEFT;
 290:src/slam.c    **** 			avoid.speed_right = AVOID_SPEED_R_ARC_RIGHT;
 291:src/slam.c    **** 			if(obstacle_right && obstacle_left)
 292:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 293:src/slam.c    **** 			if(!obstacle_left)
 294:src/slam.c    **** 			{
 295:src/slam.c    **** 				setStopwatch4(500); 
 296:src/slam.c    **** 				startStopwatch4();
 297:src/slam.c    **** 				avoid.state = AVOID_END;
 298:src/slam.c    **** 			}
 299:src/slam.c    **** 			last_obstacle = LEFT;
 300:src/slam.c    **** 			obstacle_counter++;
 301:src/slam.c    **** 		break;
 302:src/slam.c    **** 		case AVOID_END:
 303:src/slam.c    **** 			if(getStopwatch4() > 1000) // We used timing based movement here!
 304:src/slam.c    **** 			{
 305:src/slam.c    **** 				stopStopwatch4();
 306:src/slam.c    **** 				setStopwatch4(0);
 307:src/slam.c    **** 				avoid.state = IDLE;
 308:src/slam.c    **** 			}
 309:src/slam.c    **** 		break;
 310:src/slam.c    **** 	}
 311:src/slam.c    **** }
 312:src/slam.c    **** 
 313:src/slam.c    **** /**
 314:src/slam.c    ****  * ACS Event Handler - ONLY used for LED display! 
 315:src/slam.c    ****  * This does not affect the behaviour at all! 
 316:src/slam.c    ****  * The sensor checks are completely done in the Avoid behaviour
 317:src/slam.c    ****  * statemachine.
 318:src/slam.c    ****  */
 319:src/slam.c    **** void acsStateChanged(void)
 320:src/slam.c    **** {
  15               		.loc 1 320 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 321:src/slam.c    **** 	if(obstacle_left && obstacle_right)
  21               		.loc 1 321 0
  22 0000 9091 0000 		lds r25,obstacle_left
  23 0004 8091 0000 		lds r24,obstacle_right
  24 0008 9923      		tst r25
  25 000a 01F0      		breq .L2
  26               		.loc 1 321 0 is_stmt 0 discriminator 1
  27 000c 8823      		tst r24
  28 000e 01F0      		breq .L2
 322:src/slam.c    **** 		statusLEDs.byte = 0b100100;
  29               		.loc 1 322 0 is_stmt 1
  30 0010 24E2      		ldi r18,lo8(36)
  31 0012 2093 0000 		sts statusLEDs,r18
  32 0016 00C0      		rjmp .L3
  33               	.L2:
 323:src/slam.c    **** 	else
 324:src/slam.c    **** 		statusLEDs.byte = 0b000000;
  34               		.loc 1 324 0
  35 0018 1092 0000 		sts statusLEDs,__zero_reg__
  36               	.L3:
 325:src/slam.c    **** 	statusLEDs.LED5 = obstacle_left;
  37               		.loc 1 325 0
  38 001c 2091 0000 		lds r18,statusLEDs
  39 0020 90FB      		bst r25,0
  40 0022 24F9      		bld r18,4
  41 0024 2093 0000 		sts statusLEDs,r18
 326:src/slam.c    **** 	statusLEDs.LED4 = (!obstacle_left);
  42               		.loc 1 326 0
  43 0028 21E0      		ldi r18,lo8(1)
  44 002a 9111      		cpse r25,__zero_reg__
  45 002c 20E0      		ldi r18,0
  46               	.L4:
  47 002e 9091 0000 		lds r25,statusLEDs
  48 0032 20FB      		bst r18,0
  49 0034 93F9      		bld r25,3
 327:src/slam.c    **** 	statusLEDs.LED2 = obstacle_right;
  50               		.loc 1 327 0
  51 0036 80FB      		bst r24,0
  52 0038 91F9      		bld r25,1
  53 003a 9093 0000 		sts statusLEDs,r25
 328:src/slam.c    **** 	statusLEDs.LED1 = (!obstacle_right);
  54               		.loc 1 328 0
  55 003e 91E0      		ldi r25,lo8(1)
  56 0040 8111      		cpse r24,__zero_reg__
  57 0042 90E0      		ldi r25,0
  58               	.L5:
  59 0044 8091 0000 		lds r24,statusLEDs
  60 0048 90FB      		bst r25,0
  61 004a 80F9      		bld r24,0
  62 004c 8093 0000 		sts statusLEDs,r24
 329:src/slam.c    **** 	updateStatusLEDs();
  63               		.loc 1 329 0
  64 0050 0C94 0000 		jmp updateStatusLEDs
  65               	.LVL0:
  66               		.cfi_endproc
  67               	.LFE5:
  69               	.global	bumpersStateChanged
  71               	bumpersStateChanged:
  72               	.LFB3:
 197:src/slam.c    **** 	if(bumper_left && bumper_right) // Both Bumpers were hit
  73               		.loc 1 197 0
  74               		.cfi_startproc
  75               	/* prologue: function */
  76               	/* frame size = 0 */
  77               	/* stack size = 0 */
  78               	.L__stack_usage = 0
 198:src/slam.c    **** 	{
  79               		.loc 1 198 0
  80 0054 9091 0000 		lds r25,bumper_left
  81 0058 8091 0000 		lds r24,bumper_right
  82 005c 9923      		tst r25
  83 005e 01F0      		breq .L20
 198:src/slam.c    **** 	{
  84               		.loc 1 198 0 is_stmt 0 discriminator 1
  85 0060 8823      		tst r24
  86 0062 01F0      		breq .L21
 200:src/slam.c    **** 	}
  87               		.loc 1 200 0 is_stmt 1
  88 0064 81E0      		ldi r24,lo8(1)
  89 0066 00C0      		rjmp .L32
  90               	.L21:
 204:src/slam.c    **** 			escape.state = ESCAPE_LEFT;
  91               		.loc 1 204 0
  92 0068 8091 0000 		lds r24,escape+5
  93 006c 8230      		cpi r24,lo8(2)
  94 006e 01F0      		breq .L19
 205:src/slam.c    **** 	}
  95               		.loc 1 205 0
  96 0070 83E0      		ldi r24,lo8(3)
  97 0072 00C0      		rjmp .L32
  98               	.L20:
 207:src/slam.c    **** 	{
  99               		.loc 1 207 0
 100 0074 8823      		tst r24
 101 0076 01F0      		breq .L19
 102               	.LBB6:
 103               	.LBB7:
 209:src/slam.c    **** 			escape.state = ESCAPE_RIGHT;
 104               		.loc 1 209 0
 105 0078 8091 0000 		lds r24,escape+5
 106 007c 8230      		cpi r24,lo8(2)
 107 007e 01F0      		breq .L19
 210:src/slam.c    **** 	}
 108               		.loc 1 210 0
 109 0080 85E0      		ldi r24,lo8(5)
 110               	.L32:
 111 0082 8093 0000 		sts escape+5,r24
 112               	.L19:
 113 0086 0895      		ret
 114               	.LBE7:
 115               	.LBE6:
 116               		.cfi_endproc
 117               	.LFE3:
 119               	.global	behaviour_cruise
 121               	behaviour_cruise:
 122               	.LFB1:
  73:src/slam.c    **** }
 123               		.loc 1 73 0
 124               		.cfi_startproc
 125               	/* prologue: function */
 126               	/* frame size = 0 */
 127               	/* stack size = 0 */
 128               	.L__stack_usage = 0
 129 0088 0895      		ret
 130               		.cfi_endproc
 131               	.LFE1:
 133               	.global	behaviour_escape
 135               	behaviour_escape:
 136               	.LFB2:
  95:src/slam.c    **** 	static uint8_t bump_count = 0;
 137               		.loc 1 95 0
 138               		.cfi_startproc
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
  98:src/slam.c    **** 	{
 143               		.loc 1 98 0
 144 008a 8091 0000 		lds r24,escape+5
 145 008e 90E0      		ldi r25,0
 146 0090 FC01      		movw r30,r24
 147 0092 3197      		sbiw r30,1
 148 0094 E730      		cpi r30,7
 149 0096 F105      		cpc r31,__zero_reg__
 150 0098 00F0      		brlo .+2
 151 009a 00C0      		rjmp .L34
 152 009c E050      		subi r30,lo8(-(gs(.L37)))
 153 009e F040      		sbci r31,hi8(-(gs(.L37)))
 154 00a0 0C94 0000 		jmp __tablejump2__
 155               		.section	.progmem.gcc_sw_table,"a",@progbits
 156               		.p2align	1
 157               	.L37:
 158 0000 0000      		.word gs(.L36)
 159 0002 0000      		.word gs(.L38)
 160 0004 0000      		.word gs(.L39)
 161 0006 0000      		.word gs(.L40)
 162 0008 0000      		.word gs(.L41)
 163 000a 0000      		.word gs(.L42)
 164 000c 0000      		.word gs(.L43)
 165               		.text
 166               	.L36:
 103:src/slam.c    **** 			escape.dir = BWD;
 167               		.loc 1 103 0
 168 00a4 84E6      		ldi r24,lo8(100)
 169 00a6 8093 0000 		sts escape,r24
 104:src/slam.c    **** 			escape.move = true;
 170               		.loc 1 104 0
 171 00aa 8091 0000 		lds r24,escape+2
 172 00ae 8C7F      		andi r24,lo8(-4)
 105:src/slam.c    **** 			if(bump_count > 3)
 173               		.loc 1 105 0
 174 00b0 8160      		ori r24,lo8(1)
 175 00b2 8460      		ori r24,lo8(1<<2)
 176 00b4 8093 0000 		sts escape+2,r24
 106:src/slam.c    **** 				escape.move_value = 220;
 177               		.loc 1 106 0
 178 00b8 2091 0000 		lds r18,bump_count.2103
 179 00bc 2430      		cpi r18,lo8(4)
 180 00be 00F0      		brlo .L44
 107:src/slam.c    **** 			else
 181               		.loc 1 107 0
 182 00c0 8CED      		ldi r24,lo8(-36)
 183 00c2 90E0      		ldi r25,0
 184 00c4 00C0      		rjmp .L56
 185               	.L44:
 109:src/slam.c    **** 			escape.state = ESCAPE_FRONT_WAIT;
 186               		.loc 1 109 0
 187 00c6 80EA      		ldi r24,lo8(-96)
 188 00c8 90E0      		ldi r25,0
 189               	.L56:
 190 00ca 9093 0000 		sts escape+3+1,r25
 191 00ce 8093 0000 		sts escape+3,r24
 110:src/slam.c    **** 			bump_count+=2;
 192               		.loc 1 110 0
 193 00d2 82E0      		ldi r24,lo8(2)
 194 00d4 8093 0000 		sts escape+5,r24
 111:src/slam.c    **** 		break;
 195               		.loc 1 111 0
 196 00d8 2E5F      		subi r18,lo8(-(2))
 197 00da 00C0      		rjmp .L59
 198               	.L38:
 114:src/slam.c    **** 			{	
 199               		.loc 1 114 0
 200 00dc 2091 0000 		lds r18,escape+2
 201 00e0 22FD      		sbrc r18,2
 202 00e2 00C0      		rjmp .L34
 116:src/slam.c    **** 				if(bump_count > 3)
 203               		.loc 1 116 0
 204 00e4 8CE3      		ldi r24,lo8(60)
 205 00e6 8093 0000 		sts escape,r24
 117:src/slam.c    **** 				{
 206               		.loc 1 117 0
 207 00ea 8091 0000 		lds r24,bump_count.2103
 208 00ee 8430      		cpi r24,lo8(4)
 209 00f0 00F0      		brlo .L46
 119:src/slam.c    **** 					escape.dir = RIGHT;
 210               		.loc 1 119 0
 211 00f2 84E6      		ldi r24,lo8(100)
 212 00f4 90E0      		ldi r25,0
 213 00f6 9093 0000 		sts escape+3+1,r25
 214 00fa 8093 0000 		sts escape+3,r24
 120:src/slam.c    **** 					bump_count = 0;
 215               		.loc 1 120 0
 216 00fe 2360      		ori r18,lo8(3)
 217 0100 2093 0000 		sts escape+2,r18
 121:src/slam.c    **** 				}
 218               		.loc 1 121 0
 219 0104 1092 0000 		sts bump_count.2103,__zero_reg__
 220 0108 00C0      		rjmp .L47
 221               	.L46:
 125:src/slam.c    **** 					escape.move_value = 70;
 222               		.loc 1 125 0
 223 010a 822F      		mov r24,r18
 224 010c 8C7F      		andi r24,lo8(-4)
 225 010e 8260      		ori r24,lo8(2)
 226 0110 8093 0000 		sts escape+2,r24
 126:src/slam.c    **** 				}
 227               		.loc 1 126 0
 228 0114 86E4      		ldi r24,lo8(70)
 229 0116 90E0      		ldi r25,0
 230 0118 9093 0000 		sts escape+3+1,r25
 231 011c 8093 0000 		sts escape+3,r24
 232               	.L47:
 128:src/slam.c    **** 				escape.state = ESCAPE_WAIT_END;
 233               		.loc 1 128 0
 234 0120 8091 0000 		lds r24,escape+2
 235 0124 8860      		ori r24,lo8(1<<3)
 236 0126 8093 0000 		sts escape+2,r24
 237 012a 00C0      		rjmp .L55
 238               	.L39:
 133:src/slam.c    **** 			escape.dir 	= BWD;
 239               		.loc 1 133 0
 240 012c 84E6      		ldi r24,lo8(100)
 241 012e 8093 0000 		sts escape,r24
 134:src/slam.c    **** 			escape.move = true;
 242               		.loc 1 134 0
 243 0132 8091 0000 		lds r24,escape+2
 244 0136 8C7F      		andi r24,lo8(-4)
 135:src/slam.c    **** 			if(bump_count > 3)
 245               		.loc 1 135 0
 246 0138 8160      		ori r24,lo8(1)
 247 013a 8460      		ori r24,lo8(1<<2)
 248 013c 8093 0000 		sts escape+2,r24
 136:src/slam.c    **** 				escape.move_value = 190;
 249               		.loc 1 136 0
 250 0140 2091 0000 		lds r18,bump_count.2103
 251 0144 2430      		cpi r18,lo8(4)
 252 0146 00F0      		brlo .L48
 137:src/slam.c    **** 			else
 253               		.loc 1 137 0
 254 0148 8EEB      		ldi r24,lo8(-66)
 255 014a 90E0      		ldi r25,0
 256 014c 00C0      		rjmp .L57
 257               	.L48:
 139:src/slam.c    **** 			escape.state = ESCAPE_LEFT_WAIT;
 258               		.loc 1 139 0
 259 014e 86E9      		ldi r24,lo8(-106)
 260 0150 90E0      		ldi r25,0
 261               	.L57:
 262 0152 9093 0000 		sts escape+3+1,r25
 263 0156 8093 0000 		sts escape+3,r24
 140:src/slam.c    **** 			bump_count++;
 264               		.loc 1 140 0
 265 015a 84E0      		ldi r24,lo8(4)
 266               	.L60:
 267 015c 8093 0000 		sts escape+5,r24
 141:src/slam.c    **** 		break;
 268               		.loc 1 141 0
 269 0160 2F5F      		subi r18,lo8(-(1))
 270               	.L59:
 271 0162 2093 0000 		sts bump_count.2103,r18
 142:src/slam.c    **** 		case ESCAPE_LEFT_WAIT:
 272               		.loc 1 142 0
 273 0166 0895      		ret
 274               	.L40:
 144:src/slam.c    **** 			{
 275               		.loc 1 144 0
 276 0168 8091 0000 		lds r24,escape+2
 277 016c 82FD      		sbrc r24,2
 278 016e 00C0      		rjmp .L34
 146:src/slam.c    **** 				escape.dir = RIGHT;
 279               		.loc 1 146 0
 280 0170 9CE3      		ldi r25,lo8(60)
 281 0172 9093 0000 		sts escape,r25
 148:src/slam.c    **** 				if(bump_count > 3)
 282               		.loc 1 148 0
 283 0176 8360      		ori r24,lo8(3)
 284 0178 00C0      		rjmp .L63
 285               	.L41:
 160:src/slam.c    **** 			escape.dir 	= BWD;
 286               		.loc 1 160 0
 287 017a 84E6      		ldi r24,lo8(100)
 288 017c 8093 0000 		sts escape,r24
 161:src/slam.c    **** 			escape.move = true;
 289               		.loc 1 161 0
 290 0180 8091 0000 		lds r24,escape+2
 291 0184 8C7F      		andi r24,lo8(-4)
 162:src/slam.c    **** 			if(bump_count > 3)
 292               		.loc 1 162 0
 293 0186 8160      		ori r24,lo8(1)
 294 0188 8460      		ori r24,lo8(1<<2)
 295 018a 8093 0000 		sts escape+2,r24
 163:src/slam.c    **** 				escape.move_value = 190;
 296               		.loc 1 163 0
 297 018e 2091 0000 		lds r18,bump_count.2103
 298 0192 2430      		cpi r18,lo8(4)
 299 0194 00F0      		brlo .L52
 164:src/slam.c    **** 			else
 300               		.loc 1 164 0
 301 0196 8EEB      		ldi r24,lo8(-66)
 302 0198 90E0      		ldi r25,0
 303 019a 00C0      		rjmp .L58
 304               	.L52:
 166:src/slam.c    **** 			escape.state = ESCAPE_RIGHT_WAIT;
 305               		.loc 1 166 0
 306 019c 86E9      		ldi r24,lo8(-106)
 307 019e 90E0      		ldi r25,0
 308               	.L58:
 309 01a0 9093 0000 		sts escape+3+1,r25
 310 01a4 8093 0000 		sts escape+3,r24
 167:src/slam.c    **** 			bump_count++;
 311               		.loc 1 167 0
 312 01a8 86E0      		ldi r24,lo8(6)
 313 01aa 00C0      		rjmp .L60
 314               	.L42:
 171:src/slam.c    **** 			{ 
 315               		.loc 1 171 0
 316 01ac 8091 0000 		lds r24,escape+2
 317 01b0 82FD      		sbrc r24,2
 318 01b2 00C0      		rjmp .L34
 173:src/slam.c    **** 				escape.dir = LEFT;
 319               		.loc 1 173 0
 320 01b4 9CE3      		ldi r25,lo8(60)
 321 01b6 9093 0000 		sts escape,r25
 174:src/slam.c    **** 				escape.rotate = true;
 322               		.loc 1 174 0
 323 01ba 8C7F      		andi r24,lo8(-4)
 175:src/slam.c    **** 				if(bump_count > 3)
 324               		.loc 1 175 0
 325 01bc 8260      		ori r24,lo8(2)
 326               	.L63:
 327 01be 8860      		ori r24,lo8(1<<3)
 328 01c0 8093 0000 		sts escape+2,r24
 176:src/slam.c    **** 				{
 329               		.loc 1 176 0
 330 01c4 8091 0000 		lds r24,bump_count.2103
 331 01c8 8430      		cpi r24,lo8(4)
 332 01ca 00F0      		brlo .L54
 178:src/slam.c    **** 					bump_count = 0;
 333               		.loc 1 178 0
 334 01cc 8EE6      		ldi r24,lo8(110)
 335 01ce 90E0      		ldi r25,0
 336 01d0 9093 0000 		sts escape+3+1,r25
 337 01d4 8093 0000 		sts escape+3,r24
 179:src/slam.c    **** 				}
 338               		.loc 1 179 0
 339 01d8 1092 0000 		sts bump_count.2103,__zero_reg__
 340 01dc 00C0      		rjmp .L55
 341               	.L54:
 182:src/slam.c    **** 				escape.state = ESCAPE_WAIT_END;
 342               		.loc 1 182 0
 343 01de 80E5      		ldi r24,lo8(80)
 344 01e0 90E0      		ldi r25,0
 345 01e2 9093 0000 		sts escape+3+1,r25
 346 01e6 8093 0000 		sts escape+3,r24
 347               	.L55:
 183:src/slam.c    **** 			}
 348               		.loc 1 183 0
 349 01ea 87E0      		ldi r24,lo8(7)
 350 01ec 8093 0000 		sts escape+5,r24
 351 01f0 0895      		ret
 352               	.L43:
 187:src/slam.c    **** 				escape.state = IDLE;
 353               		.loc 1 187 0
 354 01f2 8091 0000 		lds r24,escape+2
 355 01f6 8C70      		andi r24,lo8(12)
 356 01f8 01F4      		brne .L34
 188:src/slam.c    **** 		break;
 357               		.loc 1 188 0
 358 01fa 1092 0000 		sts escape+5,__zero_reg__
 359               	.L34:
 360 01fe 0895      		ret
 361               		.cfi_endproc
 362               	.LFE2:
 364               	.global	behaviour_avoid
 366               	behaviour_avoid:
 367               	.LFB4:
 239:src/slam.c    **** 	static uint8_t last_obstacle = LEFT;
 368               		.loc 1 239 0
 369               		.cfi_startproc
 370               	/* prologue: function */
 371               	/* frame size = 0 */
 372               	/* stack size = 0 */
 373               	.L__stack_usage = 0
 242:src/slam.c    **** 	{
 374               		.loc 1 242 0
 375 0200 8091 0000 		lds r24,avoid+5
 376 0204 8230      		cpi r24,lo8(2)
 377 0206 01F4      		brne .+2
 378 0208 00C0      		rjmp .L66
 379 020a 00F4      		brsh .L67
 380 020c 8823      		tst r24
 381 020e 01F0      		breq .L68
 382 0210 8130      		cpi r24,lo8(1)
 383 0212 01F4      		brne .+2
 384 0214 00C0      		rjmp .L69
 385 0216 0895      		ret
 386               	.L67:
 387 0218 8330      		cpi r24,lo8(3)
 388 021a 01F0      		breq .L70
 389 021c 8530      		cpi r24,lo8(5)
 390 021e 01F4      		brne .+2
 391 0220 00C0      		rjmp .L71
 392 0222 0895      		ret
 393               	.L68:
 248:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 394               		.loc 1 248 0
 395 0224 9091 0000 		lds r25,obstacle_right
 396 0228 8091 0000 		lds r24,obstacle_left
 397 022c 9923      		tst r25
 398 022e 01F0      		breq .L72
 248:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 399               		.loc 1 248 0 is_stmt 0 discriminator 1
 400 0230 8823      		tst r24
 401 0232 01F0      		breq .L74
 249:src/slam.c    **** 			else if(obstacle_left)  // Left "sensor" has detected something
 402               		.loc 1 249 0 is_stmt 1
 403 0234 83E0      		ldi r24,lo8(3)
 404 0236 00C0      		rjmp .L100
 405               	.L72:
 250:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_LEFT;
 406               		.loc 1 250 0
 407 0238 8823      		tst r24
 408 023a 01F4      		brne .+2
 409 023c 00C0      		rjmp .L64
 251:src/slam.c    **** 			else if(obstacle_right) // Right "sensor" has detected something
 410               		.loc 1 251 0
 411 023e 82E0      		ldi r24,lo8(2)
 412               	.L100:
 413 0240 8093 0000 		sts avoid+5,r24
 414 0244 0895      		ret
 415               	.L74:
 253:src/slam.c    **** 		break;
 416               		.loc 1 253 0
 417 0246 81E0      		ldi r24,lo8(1)
 418 0248 00C0      		rjmp .L100
 419               	.L70:
 256:src/slam.c    **** 			avoid.speed_left = AVOID_SPEED_ROTATE;
 420               		.loc 1 256 0
 421 024a 9091 0000 		lds r25,last_obstacle.2120
 422 024e 9370      		andi r25,lo8(3)
 423 0250 8091 0000 		lds r24,avoid+2
 424 0254 8C7F      		andi r24,lo8(-4)
 425 0256 892B      		or r24,r25
 426 0258 8093 0000 		sts avoid+2,r24
 257:src/slam.c    **** 			avoid.speed_right = AVOID_SPEED_ROTATE;
 427               		.loc 1 257 0
 428 025c 8CE3      		ldi r24,lo8(60)
 429 025e 8093 0000 		sts avoid,r24
 258:src/slam.c    **** 			if(!(obstacle_left || obstacle_right))
 430               		.loc 1 258 0
 431 0262 8093 0000 		sts avoid+1,r24
 259:src/slam.c    **** 			{
 432               		.loc 1 259 0
 433 0266 8091 0000 		lds r24,obstacle_left
 434 026a 8111      		cpse r24,__zero_reg__
 435 026c 00C0      		rjmp .L64
 259:src/slam.c    **** 			{
 436               		.loc 1 259 0 is_stmt 0 discriminator 1
 437 026e 8091 0000 		lds r24,obstacle_right
 438 0272 8111      		cpse r24,__zero_reg__
 439 0274 00C0      		rjmp .L64
 261:src/slam.c    **** 				{
 440               		.loc 1 261 0 is_stmt 1
 441 0276 8091 0000 		lds r24,obstacle_counter.2121
 442 027a 8430      		cpi r24,lo8(4)
 443 027c 00F0      		brlo .L76
 263:src/slam.c    **** 					setStopwatch4(0);
 444               		.loc 1 263 0
 445 027e 1092 0000 		sts obstacle_counter.2121,__zero_reg__
 264:src/slam.c    **** 				}
 446               		.loc 1 264 0
 447 0282 1092 0000 		sts stopwatches+7+1,__zero_reg__
 448 0286 1092 0000 		sts stopwatches+7,__zero_reg__
 449 028a 00C0      		rjmp .L77
 450               	.L76:
 267:src/slam.c    **** 				startStopwatch4();
 451               		.loc 1 267 0
 452 028c 80E9      		ldi r24,lo8(-112)
 453 028e 91E0      		ldi r25,lo8(1)
 454 0290 9093 0000 		sts stopwatches+7+1,r25
 455 0294 8093 0000 		sts stopwatches+7,r24
 456               	.L77:
 268:src/slam.c    **** 				avoid.state = AVOID_END;
 457               		.loc 1 268 0
 458 0298 8091 0000 		lds r24,stopwatches
 459 029c 8860      		ori r24,lo8(8)
 460 029e 8093 0000 		sts stopwatches,r24
 269:src/slam.c    **** 			}
 461               		.loc 1 269 0
 462 02a2 85E0      		ldi r24,lo8(5)
 463 02a4 00C0      		rjmp .L100
 464               	.L69:
 273:src/slam.c    **** 			avoid.speed_left = AVOID_SPEED_L_ARC_LEFT;
 465               		.loc 1 273 0
 466 02a6 8091 0000 		lds r24,avoid+2
 467 02aa 8C7F      		andi r24,lo8(-4)
 468 02ac 8093 0000 		sts avoid+2,r24
 274:src/slam.c    **** 			avoid.speed_right = AVOID_SPEED_L_ARC_RIGHT;
 469               		.loc 1 274 0
 470 02b0 8EE1      		ldi r24,lo8(30)
 471 02b2 8093 0000 		sts avoid,r24
 275:src/slam.c    **** 			if(obstacle_right && obstacle_left)
 472               		.loc 1 275 0
 473 02b6 84E6      		ldi r24,lo8(100)
 474 02b8 8093 0000 		sts avoid+1,r24
 276:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 475               		.loc 1 276 0
 476 02bc 8091 0000 		lds r24,obstacle_right
 477 02c0 8823      		tst r24
 478 02c2 01F4      		brne .+2
 479 02c4 00C0      		rjmp .L78
 276:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 480               		.loc 1 276 0 is_stmt 0 discriminator 1
 481 02c6 8091 0000 		lds r24,obstacle_left
 482 02ca 8823      		tst r24
 483 02cc 01F0      		breq .L82
 277:src/slam.c    **** 			if(!obstacle_right)
 484               		.loc 1 277 0 is_stmt 1
 485 02ce 83E0      		ldi r24,lo8(3)
 486               	.L99:
 487 02d0 8093 0000 		sts avoid+5,r24
 488               	.L82:
 284:src/slam.c    **** 			obstacle_counter++;
 489               		.loc 1 284 0
 490 02d4 83E0      		ldi r24,lo8(3)
 491 02d6 00C0      		rjmp .L101
 492               	.L66:
 288:src/slam.c    **** 			avoid.speed_left = AVOID_SPEED_R_ARC_LEFT;
 493               		.loc 1 288 0
 494 02d8 8091 0000 		lds r24,avoid+2
 495 02dc 8C7F      		andi r24,lo8(-4)
 496 02de 8093 0000 		sts avoid+2,r24
 289:src/slam.c    **** 			avoid.speed_right = AVOID_SPEED_R_ARC_RIGHT;
 497               		.loc 1 289 0
 498 02e2 84E6      		ldi r24,lo8(100)
 499 02e4 8093 0000 		sts avoid,r24
 290:src/slam.c    **** 			if(obstacle_right && obstacle_left)
 500               		.loc 1 290 0
 501 02e8 8EE1      		ldi r24,lo8(30)
 502 02ea 8093 0000 		sts avoid+1,r24
 291:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 503               		.loc 1 291 0
 504 02ee 9091 0000 		lds r25,obstacle_right
 505 02f2 8091 0000 		lds r24,obstacle_left
 506 02f6 9923      		tst r25
 507 02f8 01F0      		breq .L80
 291:src/slam.c    **** 				avoid.state = AVOID_OBSTACLE_MIDDLE;
 508               		.loc 1 291 0 is_stmt 0 discriminator 1
 509 02fa 8823      		tst r24
 510 02fc 01F0      		breq .L93
 292:src/slam.c    **** 			if(!obstacle_left)
 511               		.loc 1 292 0 is_stmt 1
 512 02fe 93E0      		ldi r25,lo8(3)
 513 0300 9093 0000 		sts avoid+5,r25
 514               	.L80:
 293:src/slam.c    **** 			{
 515               		.loc 1 293 0
 516 0304 8111      		cpse r24,__zero_reg__
 517 0306 00C0      		rjmp .L81
 518               	.L93:
 295:src/slam.c    **** 				startStopwatch4();
 519               		.loc 1 295 0
 520 0308 84EF      		ldi r24,lo8(-12)
 521 030a 91E0      		ldi r25,lo8(1)
 522 030c 9093 0000 		sts stopwatches+7+1,r25
 523 0310 8093 0000 		sts stopwatches+7,r24
 296:src/slam.c    **** 				avoid.state = AVOID_END;
 524               		.loc 1 296 0
 525 0314 8091 0000 		lds r24,stopwatches
 526 0318 8860      		ori r24,lo8(8)
 527 031a 8093 0000 		sts stopwatches,r24
 297:src/slam.c    **** 			}
 528               		.loc 1 297 0
 529 031e 85E0      		ldi r24,lo8(5)
 530 0320 8093 0000 		sts avoid+5,r24
 531               	.L81:
 299:src/slam.c    **** 			obstacle_counter++;
 532               		.loc 1 299 0
 533 0324 82E0      		ldi r24,lo8(2)
 534               	.L101:
 535 0326 8093 0000 		sts last_obstacle.2120,r24
 300:src/slam.c    **** 		break;
 536               		.loc 1 300 0
 537 032a 8091 0000 		lds r24,obstacle_counter.2121
 538 032e 8F5F      		subi r24,lo8(-(1))
 539 0330 8093 0000 		sts obstacle_counter.2121,r24
 301:src/slam.c    **** 		case AVOID_END:
 540               		.loc 1 301 0
 541 0334 0895      		ret
 542               	.L71:
 303:src/slam.c    **** 			{
 543               		.loc 1 303 0
 544 0336 8091 0000 		lds r24,stopwatches+7
 545 033a 9091 0000 		lds r25,stopwatches+7+1
 546 033e 893E      		cpi r24,-23
 547 0340 9340      		sbci r25,3
 548 0342 00F0      		brlo .L64
 305:src/slam.c    **** 				setStopwatch4(0);
 549               		.loc 1 305 0
 550 0344 8091 0000 		lds r24,stopwatches
 551 0348 877F      		andi r24,lo8(-9)
 552 034a 8093 0000 		sts stopwatches,r24
 306:src/slam.c    **** 				avoid.state = IDLE;
 553               		.loc 1 306 0
 554 034e 1092 0000 		sts stopwatches+7+1,__zero_reg__
 555 0352 1092 0000 		sts stopwatches+7,__zero_reg__
 307:src/slam.c    **** 			}
 556               		.loc 1 307 0
 557 0356 1092 0000 		sts avoid+5,__zero_reg__
 558 035a 0895      		ret
 559               	.L78:
 280:src/slam.c    **** 				startStopwatch4();
 560               		.loc 1 280 0
 561 035c 84EF      		ldi r24,lo8(-12)
 562 035e 91E0      		ldi r25,lo8(1)
 563 0360 9093 0000 		sts stopwatches+7+1,r25
 564 0364 8093 0000 		sts stopwatches+7,r24
 281:src/slam.c    **** 				avoid.state = AVOID_END;
 565               		.loc 1 281 0
 566 0368 8091 0000 		lds r24,stopwatches
 567 036c 8860      		ori r24,lo8(8)
 568 036e 8093 0000 		sts stopwatches,r24
 282:src/slam.c    **** 			}
 569               		.loc 1 282 0
 570 0372 85E0      		ldi r24,lo8(5)
 571 0374 00C0      		rjmp .L99
 572               	.L64:
 573 0376 0895      		ret
 574               		.cfi_endproc
 575               	.LFE4:
 577               	.global	__floatunsisf
 578               	.global	__divsf3
 579               	.global	__fixunssfsi
 580               	.global	moveCommand
 582               	moveCommand:
 583               	.LFB6:
 330:src/slam.c    **** }
 331:src/slam.c    **** 
 332:src/slam.c    **** /*****************************************************************************/
 333:src/slam.c    **** // Behaviour control:
 334:src/slam.c    **** 
 335:src/slam.c    **** /**
 336:src/slam.c    ****  * This function processes the movement commands that the behaviours generate. 
 337:src/slam.c    ****  * Depending on the values in the behaviour_command_t struct, it sets motor
 338:src/slam.c    ****  * speed, moves a given distance or rotates.
 339:src/slam.c    ****  */
 340:src/slam.c    **** void moveCommand(behaviour_command_t * cmd)
 341:src/slam.c    **** {
 584               		.loc 1 341 0
 585               		.cfi_startproc
 586               	.LVL1:
 587 0378 1F93      		push r17
 588               	.LCFI0:
 589               		.cfi_def_cfa_offset 3
 590               		.cfi_offset 17, -2
 591 037a CF93      		push r28
 592               	.LCFI1:
 593               		.cfi_def_cfa_offset 4
 594               		.cfi_offset 28, -3
 595 037c DF93      		push r29
 596               	.LCFI2:
 597               		.cfi_def_cfa_offset 5
 598               		.cfi_offset 29, -4
 599               	/* prologue: function */
 600               	/* frame size = 0 */
 601               	/* stack size = 3 */
 602               	.L__stack_usage = 3
 603 037e EC01      		movw r28,r24
 342:src/slam.c    **** 	if(cmd->move_value > 0)  // move or rotate?
 604               		.loc 1 342 0
 605 0380 4B81      		ldd r20,Y+3
 606 0382 5C81      		ldd r21,Y+4
 607 0384 1A81      		ldd r17,Y+2
 608 0386 4115      		cp r20,__zero_reg__
 609 0388 5105      		cpc r21,__zero_reg__
 610 038a 01F0      		breq .L103
 343:src/slam.c    **** 	{
 344:src/slam.c    **** 		if(cmd->rotate)
 611               		.loc 1 344 0
 612 038c 13FF      		sbrs r17,3
 613 038e 00C0      		rjmp .L104
 345:src/slam.c    **** 			rotate(cmd->speed_left, cmd->dir, cmd->move_value, false); 
 614               		.loc 1 345 0
 615 0390 612F      		mov r22,r17
 616 0392 6370      		andi r22,lo8(3)
 617 0394 20E0      		ldi r18,0
 618 0396 8881      		ld r24,Y
 619               	.LVL2:
 620 0398 0E94 0000 		call rotate
 621               	.LVL3:
 622 039c 00C0      		rjmp .L105
 623               	.LVL4:
 624               	.L104:
 346:src/slam.c    **** 		else if(cmd->move)
 625               		.loc 1 346 0
 626 039e 12FF      		sbrs r17,2
 627 03a0 00C0      		rjmp .L105
 347:src/slam.c    **** 			move(cmd->speed_left, cmd->dir, DIST_MM(cmd->move_value), false); 
 628               		.loc 1 347 0
 629 03a2 BA01      		movw r22,r20
 630 03a4 80E0      		ldi r24,0
 631 03a6 90E0      		ldi r25,0
 632               	.LVL5:
 633 03a8 0E94 0000 		call __floatunsisf
 634               	.LVL6:
 635 03ac 2FE8      		ldi r18,lo8(-113)
 636 03ae 32EC      		ldi r19,lo8(-62)
 637 03b0 45E7      		ldi r20,lo8(117)
 638 03b2 5EE3      		ldi r21,lo8(62)
 639 03b4 0E94 0000 		call __divsf3
 640               	.LVL7:
 641 03b8 0E94 0000 		call __fixunssfsi
 642               	.LVL8:
 643 03bc 1370      		andi r17,lo8(3)
 644 03be 20E0      		ldi r18,0
 645 03c0 AB01      		movw r20,r22
 646 03c2 612F      		mov r22,r17
 647 03c4 8881      		ld r24,Y
 648 03c6 0E94 0000 		call move
 649               	.LVL9:
 650               	.L105:
 348:src/slam.c    **** 		cmd->move_value = 0; // clear move value - the move commands are only
 651               		.loc 1 348 0 discriminator 1
 652 03ca 1C82      		std Y+4,__zero_reg__
 653 03cc 1B82      		std Y+3,__zero_reg__
 654 03ce 00C0      		rjmp .L102
 655               	.LVL10:
 656               	.L103:
 657               	.LBB10:
 658               	.LBB11:
 349:src/slam.c    **** 		                     // given once and then runs in background.
 350:src/slam.c    **** 	}
 351:src/slam.c    **** 	else if(!(cmd->move || cmd->rotate)) // just move at speed? 
 659               		.loc 1 351 0
 660 03d0 812F      		mov r24,r17
 661               	.LVL11:
 662 03d2 8C70      		andi r24,lo8(12)
 663 03d4 01F4      		brne .L107
 352:src/slam.c    **** 	{
 353:src/slam.c    **** 		changeDirection(cmd->dir);
 664               		.loc 1 353 0
 665 03d6 812F      		mov r24,r17
 666 03d8 8370      		andi r24,lo8(3)
 667 03da 0E94 0000 		call changeDirection
 668               	.LVL12:
 354:src/slam.c    **** 		moveAtSpeed(cmd->speed_left,cmd->speed_right);
 669               		.loc 1 354 0
 670 03de 6981      		ldd r22,Y+1
 671 03e0 8881      		ld r24,Y
 672               	/* epilogue start */
 673               	.LBE11:
 674               	.LBE10:
 355:src/slam.c    **** 	}
 356:src/slam.c    **** 	else if(isMovementComplete()) // movement complete? --> clear flags!
 357:src/slam.c    **** 	{
 358:src/slam.c    **** 		cmd->rotate = false;
 359:src/slam.c    **** 		cmd->move = false;
 360:src/slam.c    **** 	}
 361:src/slam.c    **** }
 675               		.loc 1 361 0
 676 03e2 DF91      		pop r29
 677 03e4 CF91      		pop r28
 678               	.LVL13:
 679 03e6 1F91      		pop r17
 680               	.LBB13:
 681               	.LBB12:
 354:src/slam.c    **** 		moveAtSpeed(cmd->speed_left,cmd->speed_right);
 682               		.loc 1 354 0
 683 03e8 0C94 0000 		jmp moveAtSpeed
 684               	.LVL14:
 685               	.L107:
 356:src/slam.c    **** 	{
 686               		.loc 1 356 0
 687 03ec 0E94 0000 		call isMovementComplete
 688               	.LVL15:
 689 03f0 8823      		tst r24
 690 03f2 01F0      		breq .L102
 358:src/slam.c    **** 		cmd->move = false;
 691               		.loc 1 358 0
 692 03f4 8A81      		ldd r24,Y+2
 359:src/slam.c    **** 	}
 693               		.loc 1 359 0
 694 03f6 877F      		andi r24,lo8(-9)
 695 03f8 8B7F      		andi r24,lo8(~(1<<2))
 696 03fa 8A83      		std Y+2,r24
 697               	.LVL16:
 698               	.L102:
 699               	/* epilogue start */
 700               	.LBE12:
 701               	.LBE13:
 702               		.loc 1 361 0
 703 03fc DF91      		pop r29
 704 03fe CF91      		pop r28
 705               	.LVL17:
 706 0400 1F91      		pop r17
 707 0402 0895      		ret
 708               		.cfi_endproc
 709               	.LFE6:
 711               	.global	behaviourController
 713               	behaviourController:
 714               	.LFB7:
 362:src/slam.c    **** 
 363:src/slam.c    **** /**
 364:src/slam.c    ****  * The behaviourController task controls the subsumption architechture. 
 365:src/slam.c    ****  * It implements the priority levels of the different behaviours. 
 366:src/slam.c    ****  */
 367:src/slam.c    **** void behaviourController(void)
 368:src/slam.c    **** {
 715               		.loc 1 368 0
 716               		.cfi_startproc
 717               	/* prologue: function */
 718               	/* frame size = 0 */
 719               	/* stack size = 0 */
 720               	.L__stack_usage = 0
 369:src/slam.c    ****     // Call all the behaviour tasks:
 370:src/slam.c    **** 	behaviour_cruise();
 371:src/slam.c    **** 	behaviour_avoid();
 721               		.loc 1 371 0
 722 0404 0E94 0000 		call behaviour_avoid
 723               	.LVL18:
 372:src/slam.c    **** 	behaviour_escape();
 724               		.loc 1 372 0
 725 0408 0E94 0000 		call behaviour_escape
 726               	.LVL19:
 373:src/slam.c    **** 
 374:src/slam.c    ****     // Execute the commands depending on priority levels:
 375:src/slam.c    **** 	if(escape.state != IDLE) // Highest priority - 3
 727               		.loc 1 375 0
 728 040c 8091 0000 		lds r24,escape+5
 729 0410 8823      		tst r24
 730 0412 01F0      		breq .L115
 376:src/slam.c    **** 		moveCommand(&escape);
 731               		.loc 1 376 0
 732 0414 80E0      		ldi r24,lo8(escape)
 733 0416 90E0      		ldi r25,hi8(escape)
 734 0418 00C0      		rjmp .L118
 735               	.L115:
 377:src/slam.c    **** 	else if(avoid.state != IDLE) // Priority - 2
 736               		.loc 1 377 0
 737 041a 8091 0000 		lds r24,avoid+5
 738 041e 8823      		tst r24
 739 0420 01F0      		breq .L116
 378:src/slam.c    **** 		moveCommand(&avoid);
 740               		.loc 1 378 0
 741 0422 80E0      		ldi r24,lo8(avoid)
 742 0424 90E0      		ldi r25,hi8(avoid)
 743 0426 00C0      		rjmp .L118
 744               	.L116:
 379:src/slam.c    **** 	else if(cruise.state != IDLE) // Priority - 1
 745               		.loc 1 379 0
 746 0428 8091 0000 		lds r24,cruise+5
 747 042c 8823      		tst r24
 748 042e 01F0      		breq .L117
 380:src/slam.c    **** 		moveCommand(&cruise); 
 749               		.loc 1 380 0
 750 0430 80E0      		ldi r24,lo8(cruise)
 751 0432 90E0      		ldi r25,hi8(cruise)
 752 0434 00C0      		rjmp .L118
 753               	.L117:
 381:src/slam.c    **** 	else                     // Lowest priority - 0
 382:src/slam.c    **** 		moveCommand(&STOP);  // Default command - do nothing! 
 754               		.loc 1 382 0
 755 0436 80E0      		ldi r24,lo8(STOP)
 756 0438 90E0      		ldi r25,hi8(STOP)
 757               	.L118:
 758 043a 0C94 0000 		jmp moveCommand
 759               	.LVL20:
 760               		.cfi_endproc
 761               	.LFE7:
 763               		.section	.text.startup,"ax",@progbits
 764               	.global	main
 766               	main:
 767               	.LFB8:
 383:src/slam.c    **** 							 // In the current implementation this never 
 384:src/slam.c    **** 							 // happens.
 385:src/slam.c    **** }
 386:src/slam.c    **** 
 387:src/slam.c    **** /*****************************************************************************/
 388:src/slam.c    **** // Main:
 389:src/slam.c    **** 
 390:src/slam.c    **** int main(void)
 391:src/slam.c    **** {
 768               		.loc 1 391 0
 769               		.cfi_startproc
 770               	/* prologue: function */
 771               	/* frame size = 0 */
 772               	/* stack size = 0 */
 773               	.L__stack_usage = 0
 392:src/slam.c    **** 	initRobotBase(); 
 774               		.loc 1 392 0
 775 0000 0E94 0000 		call initRobotBase
 776               	.LVL21:
 393:src/slam.c    **** 
 394:src/slam.c    ****     writeString_P("\n\n             __.---.___\n");
 777               		.loc 1 394 0
 778 0004 80E0      		ldi r24,lo8(__c.2140)
 779 0006 90E0      		ldi r25,hi8(__c.2140)
 780 0008 0E94 0000 		call writeNStringP
 781               	.LVL22:
 395:src/slam.c    ****     writeString_P("         ___/__\\_O_/___\\___\n");
 782               		.loc 1 395 0
 783 000c 80E0      		ldi r24,lo8(__c.2142)
 784 000e 90E0      		ldi r25,hi8(__c.2142)
 785 0010 0E94 0000 		call writeNStringP
 786               	.LVL23:
 396:src/slam.c    ****     writeString_P("        /___\\__________/___\\\n");
 787               		.loc 1 396 0
 788 0014 80E0      		ldi r24,lo8(__c.2144)
 789 0016 90E0      		ldi r25,hi8(__c.2144)
 790 0018 0E94 0000 		call writeNStringP
 791               	.LVL24:
 397:src/slam.c    ****     writeString_P("        |===|\\________/|===|\n");
 792               		.loc 1 397 0
 793 001c 80E0      		ldi r24,lo8(__c.2146)
 794 001e 90E0      		ldi r25,hi8(__c.2146)
 795 0020 0E94 0000 		call writeNStringP
 796               	.LVL25:
 398:src/slam.c    ****     writeString_P("________|===|__________|===|________\n");
 797               		.loc 1 398 0
 798 0024 80E0      		ldi r24,lo8(__c.2148)
 799 0026 90E0      		ldi r25,hi8(__c.2148)
 800 0028 0E94 0000 		call writeNStringP
 801               	.LVL26:
 399:src/slam.c    **** 	writeString_P("    Pervasive Computing - Group 8\n");
 802               		.loc 1 399 0
 803 002c 80E0      		ldi r24,lo8(__c.2150)
 804 002e 90E0      		ldi r25,hi8(__c.2150)
 805 0030 0E94 0000 		call writeNStringP
 806               	.LVL27:
 400:src/slam.c    **** 	writeString_P("Simultaneous localization and mapping\n");
 807               		.loc 1 400 0
 808 0034 80E0      		ldi r24,lo8(__c.2152)
 809 0036 90E0      		ldi r25,hi8(__c.2152)
 810 0038 0E94 0000 		call writeNStringP
 811               	.LVL28:
 401:src/slam.c    **** 	writeString_P("    Jan - Felix - Tobias - Julian\n\n");
 812               		.loc 1 401 0
 813 003c 80E0      		ldi r24,lo8(__c.2154)
 814 003e 90E0      		ldi r25,hi8(__c.2154)
 815 0040 0E94 0000 		call writeNStringP
 816               	.LVL29:
 402:src/slam.c    **** 
 403:src/slam.c    **** 	setLEDs(0b111111);
 817               		.loc 1 403 0
 818 0044 8FE3      		ldi r24,lo8(63)
 819 0046 0E94 0000 		call setLEDs
 820               	.LVL30:
 404:src/slam.c    **** 	mSleep(2500);
 821               		.loc 1 404 0
 822 004a 84EC      		ldi r24,lo8(-60)
 823 004c 99E0      		ldi r25,lo8(9)
 824 004e 0E94 0000 		call mSleep
 825               	.LVL31:
 405:src/slam.c    **** 	setLEDs(0b100100); 
 826               		.loc 1 405 0
 827 0052 84E2      		ldi r24,lo8(36)
 828 0054 0E94 0000 		call setLEDs
 829               	.LVL32:
 406:src/slam.c    **** 
 407:src/slam.c    **** 	// Set Bumpers state changed event handler:
 408:src/slam.c    **** 	BUMPERS_setStateChangedHandler(bumpersStateChanged);
 830               		.loc 1 408 0
 831 0058 80E0      		ldi r24,lo8(gs(bumpersStateChanged))
 832 005a 90E0      		ldi r25,hi8(gs(bumpersStateChanged))
 833 005c 0E94 0000 		call BUMPERS_setStateChangedHandler
 834               	.LVL33:
 409:src/slam.c    **** 	
 410:src/slam.c    **** 	// Set ACS state changed event handler:
 411:src/slam.c    **** 	ACS_setStateChangedHandler(acsStateChanged);
 835               		.loc 1 411 0
 836 0060 80E0      		ldi r24,lo8(gs(acsStateChanged))
 837 0062 90E0      		ldi r25,hi8(gs(acsStateChanged))
 838 0064 0E94 0000 		call ACS_setStateChangedHandler
 839               	.LVL34:
 412:src/slam.c    **** 	
 413:src/slam.c    **** 	powerON(); // Turn on Encoders, Current sensing, ACS and Power LED.
 840               		.loc 1 413 0
 841 0068 0E94 0000 		call powerON
 842               	.LVL35:
 414:src/slam.c    **** 	setACSPwrMed(); 
 843               		.loc 1 414 0
 844 006c 0E94 0000 		call setACSPwrMed
 845               	.LVL36:
 846               	.L120:
 415:src/slam.c    **** 	
 416:src/slam.c    **** 	// Main loop
 417:src/slam.c    **** 	while(true) 
 418:src/slam.c    **** 	{		
 419:src/slam.c    **** 		behaviourController();
 847               		.loc 1 419 0 discriminator 1
 848 0070 0E94 0000 		call behaviourController
 849               	.LVL37:
 420:src/slam.c    **** 		task_RP6System();
 850               		.loc 1 420 0 discriminator 1
 851 0074 0E94 0000 		call task_RP6System
 852               	.LVL38:
 853 0078 00C0      		rjmp .L120
 854               		.cfi_endproc
 855               	.LFE8:
 857               		.section	.progmem.data,"a",@progbits
 860               	__c.2154:
 861 0000 2020 2020 		.string	"    Jan - Felix - Tobias - Julian\n\n"
 861      4A61 6E20 
 861      2D20 4665 
 861      6C69 7820 
 861      2D20 546F 
 864               	__c.2152:
 865 0024 5369 6D75 		.string	"Simultaneous localization and mapping\n"
 865      6C74 616E 
 865      656F 7573 
 865      206C 6F63 
 865      616C 697A 
 868               	__c.2150:
 869 004b 2020 2020 		.string	"    Pervasive Computing - Group 8\n"
 869      5065 7276 
 869      6173 6976 
 869      6520 436F 
 869      6D70 7574 
 872               	__c.2148:
 873 006e 5F5F 5F5F 		.string	"________|===|__________|===|________\n"
 873      5F5F 5F5F 
 873      7C3D 3D3D 
 873      7C5F 5F5F 
 873      5F5F 5F5F 
 876               	__c.2146:
 877 0094 2020 2020 		.string	"        |===|\\________/|===|\n"
 877      2020 2020 
 877      7C3D 3D3D 
 877      7C5C 5F5F 
 877      5F5F 5F5F 
 880               	__c.2144:
 881 00b2 2020 2020 		.string	"        /___\\__________/___\\\n"
 881      2020 2020 
 881      2F5F 5F5F 
 881      5C5F 5F5F 
 881      5F5F 5F5F 
 884               	__c.2142:
 885 00d0 2020 2020 		.string	"         ___/__\\_O_/___\\___\n"
 885      2020 2020 
 885      205F 5F5F 
 885      2F5F 5F5C 
 885      5F4F 5F2F 
 888               	__c.2140:
 889 00ed 0A0A 2020 		.string	"\n\n             __.---.___\n"
 889      2020 2020 
 889      2020 2020 
 889      2020 205F 
 889      5F2E 2D2D 
 890               		.local	obstacle_counter.2121
 891               		.comm	obstacle_counter.2121,1,1
 892               		.data
 895               	last_obstacle.2120:
 896 0000 02        		.byte	2
 897               		.local	bump_count.2103
 898               		.comm	bump_count.2103,1,1
 899               	.global	avoid
 900               		.section .bss
 903               	avoid:
 904 0000 0000 0000 		.zero	6
 904      0000 
 905               	.global	escape
 908               	escape:
 909 0006 0000 0000 		.zero	6
 909      0000 
 910               	.global	cruise
 911               		.data
 914               	cruise:
 915 0001 64        		.byte	100
 916 0002 64        		.byte	100
 917 0003 00        		.byte	0
 918 0004 0000      		.word	0
 919 0006 01        		.byte	1
 920               	.global	STOP
 921               		.section .bss
 924               	STOP:
 925 000c 0000 0000 		.zero	6
 925      0000 
 926               		.comm	timer,2,1
 927               		.comm	motion_status,1,1
 928               		.comm	statusLEDs,1,1
 929               		.text
 930               	.Letext0:
 931               		.file 2 "/usr/avr/include/stdint.h"
 932               		.file 3 "lib/RP6Lib/RP6base/RP6RobotBaseLib.h"
 933               		.file 4 "lib/RP6Lib/RP6common/RP6uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 slam.c
     /tmp/ccxZM82q.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccxZM82q.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccxZM82q.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccxZM82q.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccxZM82q.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccxZM82q.s:12     .text:0000000000000000 acsStateChanged
                            *COM*:0000000000000001 statusLEDs
     /tmp/ccxZM82q.s:71     .text:0000000000000054 bumpersStateChanged
     /tmp/ccxZM82q.s:908    .bss:0000000000000006 escape
     /tmp/ccxZM82q.s:121    .text:0000000000000088 behaviour_cruise
     /tmp/ccxZM82q.s:135    .text:000000000000008a behaviour_escape
     /tmp/ccxZM82q.s:891    .bss:0000000000000013 bump_count.2103
     /tmp/ccxZM82q.s:366    .text:0000000000000200 behaviour_avoid
     /tmp/ccxZM82q.s:903    .bss:0000000000000000 avoid
     /tmp/ccxZM82q.s:895    .data:0000000000000000 last_obstacle.2120
                             .bss:0000000000000012 obstacle_counter.2121
     /tmp/ccxZM82q.s:582    .text:0000000000000378 moveCommand
     /tmp/ccxZM82q.s:713    .text:0000000000000404 behaviourController
     /tmp/ccxZM82q.s:914    .data:0000000000000001 cruise
     /tmp/ccxZM82q.s:924    .bss:000000000000000c STOP
     /tmp/ccxZM82q.s:766    .text.startup:0000000000000000 main
     /tmp/ccxZM82q.s:888    .progmem.data:00000000000000ed __c.2140
     /tmp/ccxZM82q.s:884    .progmem.data:00000000000000d0 __c.2142
     /tmp/ccxZM82q.s:880    .progmem.data:00000000000000b2 __c.2144
     /tmp/ccxZM82q.s:876    .progmem.data:0000000000000094 __c.2146
     /tmp/ccxZM82q.s:872    .progmem.data:000000000000006e __c.2148
     /tmp/ccxZM82q.s:868    .progmem.data:000000000000004b __c.2150
     /tmp/ccxZM82q.s:864    .progmem.data:0000000000000024 __c.2152
     /tmp/ccxZM82q.s:860    .progmem.data:0000000000000000 __c.2154
                            *COM*:0000000000000002 timer
                            *COM*:0000000000000001 motion_status

UNDEFINED SYMBOLS
obstacle_left
obstacle_right
updateStatusLEDs
bumper_left
bumper_right
__tablejump2__
stopwatches
__floatunsisf
__divsf3
__fixunssfsi
rotate
move
changeDirection
moveAtSpeed
isMovementComplete
initRobotBase
writeNStringP
setLEDs
mSleep
BUMPERS_setStateChangedHandler
ACS_setStateChangedHandler
powerON
setACSPwrMed
task_RP6System
__do_copy_data
__do_clear_bss
